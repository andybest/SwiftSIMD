/*
 MIT License
 Copyright (c) 2017 Andy Best
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */

/* This file is automatically generated by the GenBoilerplate target */

import Foundation
import simd

extension float4 {
    /// A vector with all elements initialized to 0
    public var zero: float4 { return float4() }
    /// The length of the vector
    public var length: Float { return simd.length(self) }
    /// The elements of the vector as an array
    public var array: [Float] {
        return [x, y, z, w]
    }
    /// Returns a vector with all elements normalized so that the length equals zero
    public var normalized: float4 {
        return simd.normalize(self)
    }
    /// Sum of the elements in the vector
    public var summedElements: Float {
        return simd.reduce_add(self)
    }
    /// Minimum element of the vector
    public var minElement: Float {
        return simd.reduce_min(self)
    }
    /// Maximum element of the vector
    public var maxElement: Float {
        return simd.reduce_max(self)
    }
    /// The dot product of the vector and the parameter
    public func dot(_ other: float4) -> Float {
        return simd.dot(self, other)
    }
    /// Linear interpolation between the vector and a given vector by t
    public func interpolated(with other: float4, by t: Float) -> float4 {
        return simd.mix(self, other, t: t)
    }
    /// Vector-scalar minimum. Each component of the result is the minimum of the corresponding element of the vector
    /// and the scalar
    public func min(_ scalar: Float) -> float4 {
        return simd.min(self, scalar)
    }
    /// Vector-scalar maximum. Each component of the result is the maximum of the corresponding element of the vector
    /// and the scalar
    public func max(_ scalar: Float) -> float4 {
        return simd.max(self, scalar)
    }
    /// Clamp each element of the vector between the corresponding elements of the given min/max vectors
    public func clamped(min: float4, max: float4) -> float4 {
        return simd.clamp(self, min: min, max: max)
    }
    /// Clamp the vector between the given scalar values
    public func clamped(min: Float, max: Float) -> float4 {
        return simd.clamp(self, min: min, max: max)
    }
}